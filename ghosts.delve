def xs = range[1.0, grid_w, 1.0]
def ys = range[1.0, grid_h, 1.0]

def decision_point = x,y :
    xs(x) and ys(y) and
    not wall(x,y) and
        // Anything that's not a hallway or a corner:
        // (Dead-end tunnels, three-way intersections, and four-way intersections)
        num_paths[x,y] != 2

def display_grid[x, y](c) =
    decision_point(x,y) and c = 'D'

@inline
def num_paths[x,y] = 0
        + if not wall(x+1, y) then 1 else 0 end
        + if not wall(x,   y+1) then 1 else 0 end
        + if not wall(x-1, y) then 1 else 0 end
        + if not wall(x,   y-1) then 1 else 0 end

def path_options[x,y] = x1, y1 :
    xs(x) and ys(y) and
    not wall(x,y) and not wall(x1,y1)
        and {
            x+1, y;
            x,   y+1;
            x-1, y+1;
            x,   y-1;
        }(x1, y1)

// Currently, all ghosts except blinky stay put
// def computed_new_pos_ghost[g in ghost](vs...) = g != blinky and ghost_pos[g](vs...)

// ------ Blinky AI ------------

def blinky_pos = ghost_pos[blinky]
def blinky_x = blinky_pos[:x]
def blinky_y = blinky_pos[:y]
def blinky_facing = ghost_facing[blinky]

def blinky_new_pos =
    if not decision_point[blinky_x, blinky_y] then
        // YIKES! Why is this so complicated looking? I'm just trying to say:
        //  "go straight unless it's a wall, in which case go down the path you didn't come from"
        {:x,x; :y,y}
        from (x,y) where
            if not wall(next_x, next_y) then
                // Continue down the hallway
                x = next_x and y = next_y
            else
                // Take the corner path (the path you didn't come from)
                path_options[blinky_x,blinky_y](x,y) and not (prev_x,prev_y)(x,y)
            end
            // Compute the direction already heading
            from (next_x,next_y, prev_x,prev_y) where
                next_x = blinky_pos[:x] + blinky_facing[:x] and
                next_y = blinky_pos[:y] + blinky_facing[:y] and
                prev_x = blinky_pos[:x] - blinky_facing[:x] and
                prev_y = blinky_pos[:y] - blinky_facing[:y]
    else  // decision point
        // TODO
        d : blinky_pos[d] + blinky_facing[d]
    end

// TODO: This is probably too obvious to even check, but also it's broken, and it's slow
// ic hallways_and_corners_not_decision_points(x,y) {
//     (not wall(x,y) and not decision_point(x,y)) implies num_paths[x,y] = 2
// }


// def delete[:ghost_facing] = blinky, vs... : insert(:tick) and ghost_facing[blinky](vs...)
//
// def insert[:ghost_facing] = blinky, :x, 1.0
// def insert[:ghost_facing] = blinky, :y, 0.0


def blinky = ghost_by_id[1]

// (includes wrapping via the portals)
def computed_new_pos_ghost[g,d](v) = g=blinky and v =
    (blinky_new_pos[d] - 1.0) % grid_dim[d] + 1.0


//def delete[:ghost_pos][g in ghost](vs...) = insert(:tick) and ghost_pos[g](vs...)
//def insert[:ghost_pos][g in ghost](vs...) = insert(:tick) and computed_new_pos_ghost[g](vs...)

// TODO: somehow this deletes _all_ the ghost positions instead of just Blinky
// I think this is a bug:
def delete[:ghost_pos][g in blinky](vs...) = insert(:tick) and ghost_pos[g](vs...)
def insert[:ghost_pos][g in blinky](vs...) = insert(:tick) and computed_new_pos_ghost[g](vs...)





/*  The below is broken: https://github.com/RelationalAI/raicode/issues/3265

@inline
def move_towards[ax,ay, bx,by] = ax+x, ay+y
    from x,y where
        if abs[dx] > abs[dy] then
            if not wall(ax+rx, ay) then
                x=rx and y=0.0
            else if not wall(ax, ay+ry) then
                x=0.0 and y=ry
            else if not wall(ax, ay-ry) then
                x=0.0 and y=-ry
            else if not wall(ax-rx, ay) then
                x=-rx and y=0.0
            else
                x=0.0 and y=0.0 // (boxed in)
            end end end end
        else // y is bigger
            if not wall(ax, ay+ry) then
                x=0.0 and y=ry
            else if not wall(ax+rx, ay) then
                x=rx and y=0.0
            else if not wall(ax-rx, ay) then
                x=-rx and y=0.0
            else if not wall(ax, ay-ry) then
                x=0.0 and y=-ry
            else
                x=0.0 and y=0.0 // (boxed in)
            end end end end
        end

    from dx,dy, rx, ry
    where
        dx = bx - ax and
        dy = by - ay
        // (Default to moving bottom-right)
        and rx = if dx=0.0 then 1.0 else dx/abs[dx] end
        and ry = if dy=0.0 then 1.0 else dy/abs[dy] end

def chaser = ghost_by_id[1]

 def chaser_new_pos = move_towards[
     ghost_pos[chaser][:x], ghost_pos[chaser][:y],
     pacman_pos[:x], pacman_pos[:y]
 ]

// Update positions based on pending moves.
def delete[:ghost_pos][chaser][:x](v) = insert(:tick) and ghost_pos[chaser][:x](v)
def delete[:ghost_pos][chaser][:y](v) = insert(:tick) and ghost_pos[chaser][:y](v)
def insert[:ghost_pos][chaser][:x](v) = insert(:tick) and chaser_new_pos(v)[:x]
def insert[:ghost_pos][chaser][:y](v) = insert(:tick) and chaser_new_pos(v)[:y]

*/

//def chaser_move_direction =
//    if not wall(cx,cy) then
//        {:x, cx; :y, cy}
//    else if
//    from cx,cy
//    where
//        closest_direction[ghost_pos[:x][chaser], ghost_y[chaser], pacman_pos[:x], pacman_pos[:y]][:x](cx)
//        closest_direction[ghost_pos[:x][chaser], ghost_y[chaser], pacman_pos[:x], pacman_pos[:y]][:y](cy)


// ------ AI ------------------------------------------
// def xs = range[1.0, grid_w, 1.0]
// def ys = range[1.0, grid_h, 1.0]
//
// entity node node_by_xy = xs,ys
//
// def edge(a,b) = node_by_xy(ax,ay,a) and node_by_xy(bx,by,b) and
//     {1.0; 0.0}(abs[bx - ax]) and
//     {1.0; 0.0}(abs[by - ay]) and
//     a != b
//     from (ax,ay,bx,by)
//
// @inline
// def shortest_path[a, b][d] = edge(a, b) and d = 1
// @inline
// def shortest_path[a, b][v] = Min[w: shortest_path(a, b, w) or exists(t: w = shortest_path[a,t] +1 and edge(t, b))](v)
//
//