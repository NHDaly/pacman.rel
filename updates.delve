// --- Debugging -----------------------

// Uncomment these to enable debugging of all inserts and deletes:
// def output[:insertlog](p,xs...) = insert(p,xs...)
// TODO: Deletelog doesn't work for some unknown reason:
// // def output[:deletelog](p,xs...) = delete(p,xs...)
// // def insert[:dummy,1,2,3] = ()
// // def delete[:dummy,1,2,3] = ()

// ============================================================
// === Updates
// ============================================================

// ---------------------------------------
// Motion!

// TODO: reuse code in the below ICs
//@inline def is_unit_vector(P) =
//    P[:x](vx) and P[:y](vy) implies
//        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
//        and vx != vy and (vx+vy = 1 or vx+vy = -1)

ic pacman_facing_is_unit_vec(vx,vy) {
    pacman_facing[:x](vx) and pacman_facing[:y](vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}
ic ghost_facing_is_unit_vec(g,vx,vy) {
    ghost_facing[g][:x](vx) and ghost_facing[g][:y](vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}


def pacman_move = pacman_facing  // e.g. { x: 1,  y: 0 } for moving right

def grid_dim = {:x, grid_w;  :y, grid_h}

// Moving Pacman based on controller input

def computed_new_pos_pacman[d] = (pacman_pos[d] + pacman_move[d] - 1.0) % grid_dim[d] + 1.0

def valid_move_pacman =
    computed_new_pos_pacman[:x](x) and computed_new_pos_pacman[:y](y)
    and not wall(x,y) // and not dead
    from x,y

// ***** On :tick, update positions ***********

// Update positions based on pending moves.
def delete[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and pacman_pos(vs...)
def insert[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and computed_new_pos_pacman(vs...)


// -- Eating! -------------------------------
def delete[:dot](x,y) = dot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

def delete[:superdot](x,y) = superdot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

// Every time we delete a dot, add a point
def insert[:score](v) = delete[:dot](_,_) and v = score+1.0
def delete[:score](v) = delete[:dot](_,_) and score(v)

def insert[:score](v) = delete[:superdot](_,_) and v = score+10.0
def delete[:score](v) = delete[:superdot](_,_) and score(v)


// -- Ghosts Interactions -------------------
/*
// This still isn't working quite right.. Pacman continues on invisible and eating after death!

def death = tile_occupant[x,y](p) and tile_occupant[x,y](g)
    from x,y,p,g where pacman(p) and ghost(g)

// On a death condition, pacman becomes dead, and stays dead until the level restarts.
def insert[:dead] = not(dead) and death

def delete[:lives](v) = insert(:dead) and lives(v)
def insert[:lives](v) = insert(:dead) and v = lives-1

// When pacman dies, remove it from the board
def delete[:pacman_pos] = vs... : insert(:dead) and pacman_pos(vs...)
*/