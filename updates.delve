// Moved this to a separate file so that the definitions could come after level is loaded
// due to bugs in Delve.
// Also it's probably just good to separate things into files.

// ============================================================
// === Updates
// ============================================================

// ---------------------------------------
// Motion!

// TODO: reuse code in the below ICs
//@inline def is_unit_vector(P) =
//    P[:x](vx) and P[:y](vy) implies
//        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
//        and vx != vy and (vx+vy = 1 or vx+vy = -1)

ic pacman_facing_is_unit_vec(vx,vy) {
    pacman_facing[:x](vx) and pacman_facing[:y](vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}
ic ghost_facing_is_unit_vec(g,vx,vy) {
    ghost_facing_x(g, vx) and ghost_facing_y(g, vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}


def pacman_move = pacman_facing

def grid_dim = {:x, grid_w;  :y, grid_h}

// Moving Pacman based on controller input

def computed_new_pos_pacman[d] = (pacman_pos[d] + pacman_move[d] - 1.0) % grid_dim[d] + 1.0
//def computed_new_ghost[g in ghost] = ghost_x[g] + ghost_move_x[g], ghost_y + ghost_move_y[g]

def valid_move_pacman =
    computed_new_pos_pacman[:x](x) and computed_new_pos_pacman[:y](y)
    and not wall(x,y) // and not dead
    from x,y

// ***** On :tick, update positions ***********

// Update positions based on pending moves.
def delete[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and pacman_pos(vs...)
def insert[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and computed_new_pos_pacman(vs...)

//def delete[:ghost_pos](g, x,y) = insert(:tick) and computed_new_ghost_pos(g,_,_) and ghost_pos(m,x,y)
//def insert[:ghost_pos](g, x,y) = insert(:tick) and computed_new_ghost_pos(g,x,y)


// -- Eating! -------------------------------
def delete[:dot](x,y) = dot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

def delete[:superdot](x,y) = superdot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

// Every time we delete a dot, add a point
def insert[:score](v) = delete[:dot](_,_) and v = score+1.0
def delete[:score](v) = delete[:dot](_,_) and score(v)

def insert[:score](v) = delete[:superdot](_,_) and v = score+10.0
def delete[:score](v) = delete[:superdot](_,_) and score(v)


// -- Ghosts Interactions -------------------
/*
// This still isn't working quite right.. Pacman continues on invisible and eating after death!

def death = tile_occupant[x,y](p) and tile_occupant[x,y](g)
    from (x,y,p,g) where pacman(p) and ghost(g)

// On a death condition, pacman becomes dead, and stays dead until the level restarts.
def insert[:dead] = not(dead) and death

def delete[:lives](v) = insert(:dead) and lives(v)
def insert[:lives](v) = insert(:dead) and v = lives-1

// When pacman dies, remove it from the board
def delete[:pacman_pos] = vs... : insert(:dead) and pacman_pos(vs...)
*/