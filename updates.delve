// --- Debugging -----------------------

// def insert[:deletelog](p, xs...) = delete(p, xs...)
//
// // TODO: The vararg insertlog isn't working currently -- needs varargs in fixpoint:
// // https://github.com/RelationalAI/raicode/issues/3266#issuecomment-731779346
// def insert[:insertlog](p, x1) = insert(p, x1) and not {:insertlog; :deletelog}(p)
// def insert[:insertlog](p, x1,x2) = insert(p, x1,x2) and not {:insertlog; :deletelog}(p)
// def insert[:insertlog](p, x1,x2,x3) = insert(p, x1,x2,x3) and not {:insertlog; :deletelog}(p)
// def insert[:insertlog](p, x1,x2,x3,x4) = insert(p, x1,x2,x3,x4) and not {:insertlog; :deletelog}(p)


// ============================================================
// === Updates
// ============================================================

// ---------------------------------------
// Motion!

// TODO: reuse code in the below ICs
//@inline def is_unit_vector(P) =
//    P[:x](vx) and P[:y](vy) implies
//        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
//        and vx != vy and (vx+vy = 1 or vx+vy = -1)

ic pacman_facing_is_unit_vec(vx,vy) {
    pacman_facing[:x](vx) and pacman_facing[:y](vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}
ic ghost_facing_is_unit_vec(g,vx,vy) {
    ghost_facing[g][:x](vx) and ghost_facing[g][:y](vy) implies
        {-1.0; 0.0; 1.0}(vx) and {-1.0; 0.0; 1.0}(vy)
        and vx != vy and (vx+vy = 1 or vx+vy = -1)
}


def pacman_move = pacman_facing

def grid_dim = {:x, grid_w;  :y, grid_h}

// Moving Pacman based on controller input

def computed_new_pos_pacman[d] = (pacman_pos[d] + pacman_move[d] - 1.0) % grid_dim[d] + 1.0
//def computed_new_ghost[g in ghost] = ghost_pos[g][:x] + ghost_move_x[g], ghost_pos[g][:y] + ghost_move_y[g]

def valid_move_pacman =
    computed_new_pos_pacman[:x](x) and computed_new_pos_pacman[:y](y)
    and not wall(x,y) // and not dead
    from x,y

// ***** On :tick, update positions ***********

// Update positions based on pending moves.
def delete[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and pacman_pos(vs...)
def insert[:pacman_pos](vs...) = insert(:tick) and valid_move_pacman() and computed_new_pos_pacman(vs...)


// -- Eating! -------------------------------
def delete[:dot](x,y) = dot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

def delete[:superdot](x,y) = superdot(x,y) and pacman_pos[:x](x) and pacman_pos[:y](y)

// Every time we delete a dot, add a point
def insert[:score](v) = delete[:dot](_,_) and v = score+1.0
def delete[:score](v) = delete[:dot](_,_) and score(v)

def insert[:score](v) = delete[:superdot](_,_) and v = score+10.0
def delete[:score](v) = delete[:superdot](_,_) and score(v)


// -- Ghosts Interactions -------------------
/*
// This still isn't working quite right.. Pacman continues on invisible and eating after death!

def death = tile_occupant[x,y](p) and tile_occupant[x,y](g)
    from (x,y,p,g) where pacman(p) and ghost(g)

// On a death condition, pacman becomes dead, and stays dead until the level restarts.
def insert[:dead] = not(dead) and death

def delete[:lives](v) = insert(:dead) and lives(v)
def insert[:lives](v) = insert(:dead) and v = lives-1

// When pacman dies, remove it from the board
def delete[:pacman_pos] = vs... : insert(:dead) and pacman_pos(vs...)
*/