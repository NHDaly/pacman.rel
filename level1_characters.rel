// TODO: This doesn't work yet, though it would be cool. It needs modules, or
//       top-level reification of definitions:
//       https://relationalai.slack.com/archives/CTLEJ99EW/p1605984400258700
/*
// For this file, delete any existing values for all relations we're inserting.
def _new_inserts(p,vs...) = insert(p, vs...)
def delete[p](oldvals...) = p(oldvals...)
*/

// Use this to trigger all the inserts and deletes below, by issuing an update txn
// with e.g. `insert[:init_level] = 1`.
def init_l(l) = insert[:init_level](l)


// (Note the boundary is walls)
def l1_grid_h = 31.0
def l1_grid_w = 28.0

def delete = (:grid_w,grid_w ; :grid_h,grid_h),  init_l(1)
def insert[:grid_w] = l1_grid_w,  init_l(1)
def insert[:grid_h] = l1_grid_h,  init_l(1)


// Install edbs for pacman pos
def delete[:pacman_pos] = pacman_pos,  init_l(1)
def insert[:pacman_pos] = { :x, 14.0;  :y, 8.0 },  init_l(1)
def insert[:dead] = false  // no-op, but prevents undef compile errors

// All the ghosts start in the cage, in the middle (except blinky)
def delete[:ghost_pos] = ghost_pos,  init_l(1)
def insert[:ghost_pos][g in ghost][:x] = ghost_init_x - (gid - 2.5) from gid where ghost_by_id(gid,g) and init_l(1)
def insert[:ghost_pos][g in ghost][:y] = ghost_init_y, g != blinky  and init_l(1)

// start blinky in the middle, out of the cage!
def insert[:ghost_pos][g in blinky][:y] = ghost_init_y + 3.0,  init_l(1)

def blinky = ghost_by_id[1]

def ghost_init_x = 14.5
def ghost_init_y = l1_grid_h/2.0 + 1.5


// Facing direction

def delete[:pacman_facing] = pacman_facing,  init_l(1)
def insert[:pacman_facing][:x] = 1.0,  init_l(1)
def insert[:pacman_facing][:y] = 0.0,  init_l(1)

def delete[:ghost_facing][g in ghost] = ghost_facing[g],  init_l(1)
def insert[:ghost_facing][g in ghost][:x] = 1.0,  init_l(1)
def insert[:ghost_facing][g in ghost][:y] = 0.0,  init_l(1)



// Score Keeping
def delete[:score] = score,  init_l(1)
def insert[:score] = 0.0,  init_l(1)

def delete[:lives] = lives,  init_l(1)
def insert[:lives] = 3,  init_l(1)
