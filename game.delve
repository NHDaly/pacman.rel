// TODO: need this to make inserts work
def insert[:dummy] = true

// --- Ghost Configs -------------------------

// From https://en.wikipedia.org/wiki/Ghosts_(Pac-Man)#Known_ghosts
def ghost_name = {
    1, "Blinky";  // Chaser
    2, "Pinky";   // Ambusher
    3, "Inky";    // Fickle
    4, "Clide";   // Feigned Ignorance
}
def ghost_color = {
    1, "red";
    2, "pink";
    3, "cyan";
    4, "orange";
}

def ghost(g) = ghost_name(g,_)

// TODO: Couldn't RAIVM w/ existentials for x,y. Is this broken?
// TODO: Can't RAIVM these together. Is this broken?
// ic all_ghosts_on_board(g) {
//     (ghost_x(g, x) implies (x >= 0 and x <= grid_w + 1) from x) and
//     (ghost_y(g, y) implies (y >= 0 and y <= grid_h + 1) from y)
// }
// ic all_ghosts_on_board_x(g,x) {
//     ghost_x(g, x) implies (x >= 0 and x <= grid_w + 1)
// }
// ic all_ghosts_on_board_y(g,y) {
//     ghost_y(g, y) implies (y >= 0 and y <= grid_h + 1)
// }

// ---- Walls and Dots --------

// Walls and dots should be loaded via CSV. They're initialized here just to make things work.
//def insert[:walls_csv](x,y) = insert(:init) and x=0.0 and y=0.0
//def insert[:superdots_csv](x,y) = insert(:init) and x=0.0 and y=0.0


/*
    // Start with a box around the ghosts
    exists(i,j : {-2.0,-1.0,0.0,1.0,2.0}(i) and {-2.0,-1.0,0.0,1.0,2.0}(j) and
        (grid_w/2.0 + i)(x) and (grid_h/2.0 + j)(y) and
            (i = 2 or i = -2 or j = 2 or j = -2)
        )
*/



// ---------------------------------------
// Motion!

//ic pacman_facing_is_unit_vec(vx,vy) {
//    pacman_facing_x(vx) and pacman_facing_y(vy) implies {-1;0;1}(vx) and {-1;0;1}(vy)
//        and vx != vy and (vx+vy = 1 or vx+vy = -1)
//}
//ic ghost_facing_is_unit_vec(g,vx,vy) {
//    ghost_facing_x(g, vx) and ghost_facing_y(g, vy) implies {-1;0;1}(vx) and {-1;0;1}(vy)
//        and vx != vy and (vx+vy = 1 or vx+vy = -1)
//}



// TODO: Stop at Walls
def pacman_move_x = pacman_facing_x
def pacman_move_y = pacman_facing_y




// --- Game Positioning ---------------------------------------

// Reverse index by tile - players, monster, etc
// TODO: Once we have specialization this will work! :)
// def tile_occupant[x,y] = p : pacman[p] and pacman_pos(p, x,y)
// def tile_occupant[x,y] = m : ghost[m] and ghost_pos(m, x,y)

def tile_occupant_pacman(x,y) = pacman_x(x) and pacman_y(y)
def tile_occupant_ghost[x,y] = g : ghost(g) and ghost_x(g, x) and ghost_y(g, y)

// ------------------------------------------------------------

// ============================================================
// === UI Rendering
// ============================================================

// TODO: Extracting characters from strings
// def pc_display_char[p in pc] = substring[pc_name[p], 1,1]
//def ghost_display_char[g in ghost] = substring[ghost_name[g], 1,1]


def pacman_display_char = 'P'  // Sad, Delve rejected 'á—§'
def ghost_display_char = {
    1, '1';
    2, '2';
    3, '3';
    4, '4';
}

def display_grid[x, y](c) =
    tile_occupant_pacman(x,y) and pacman_display_char(c)
        or (tile_occupant_ghost(x,y,g) and ghost_display_char[g](c) from g in ghost)
        or dot(x,y) and c='.'
        or superdot(x,y) and c='*'
        or wall(x,y) and c='W'

// Flip y axis for printing characters!
def display_grid_topdown[display_x, display_y] =
    display_grid[x, y]
    from (x,y)
    where display_x = x and display_y = grid_h - y + 1


// Old version where i was printing the whole grid as a block in delve
//def display_grid[x in range[L,R,1], y in range[B,T,1]] =
//    if tile_occupant_pacman(x,y) then pacman_display_char
//    else if tile_occupant_ghost(x,y,_) then ghost_display_char[tile_occupant_ghost[x,y]]
//    else '.'
//    end end
//
//// Flip y axis for printing characters!
//def display_lines[row in range[1,screen_height,1], col in range[1,screen_width,1]] =
//    display_grid[x, y]
//    from (x,y)
//    where x = L + col - 1 and y = T - row + 1


// ------------------------------------------------------------

/*


// ============================================================
// === Updates
// ============================================================

//TODO(1898) remove after fixing issue #1898
    def insert(:dummy) = true
    def insert[:move] = (10000, :up)
    def delete[:move] = (10000, :up)
//

def mv_vec = {
    :up,     0, 1;
    :down,   0,-1;
    :left,  -1, 0;
    :right,  1, 0;
}
def mv_dir = d : mv_vec(d,_,_)

@inline def vadd[A, B] = (px+vx, py+vy) from px,py, vx,vy where A(px,py) and B(vx,vy)

def computed_new_pos[p in pc] = vadd[pc_pos[p], mv_vec[d]] from id,d where move(id,d) and pc_by_id[id](p)

def computed_new_monster_pos[m in monster] = vadd[monster_pos[m], monster_AI_move[m]]


// ***** On :tick, update everything ***********
// TODO: Need different ticks until specialization is done
// TODO: NVM this doesn't work either. i just need to either wait for specialization, or make players and monsters have the same type.

// Update positions based on pending moves.
def delete[:pc_pos](p, x,y) = insert(:ptick) and computed_new_pos(p,_,_) and pc_pos(p,x,y)
def insert[:pc_pos](p, x,y) = insert(:ptick) and computed_new_pos(p,x,y)

// Delete pending moves.
def delete[:move](v...) = insert(:ptick) and move(v...)

def delete[:monster_pos](m, x,y) = insert(:mtick) and computed_new_monster_pos(m,_,_) and monster_pos(m,x,y)
def insert[:monster_pos](m, x,y) = insert(:mtick) and computed_new_monster_pos(m,x,y)


*/