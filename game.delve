// bound party_pos[]
// Install an edb mapping party id to current position
// def insert[:pc_pos] = init_pos

/*  CSV Loading ... blech! ...

def party_config_csv = load_csv["/Users/daly/Documents/work/rai/delve-code/game-config.csv"]
//def Class(v...) = exists(pos: y[pos, :Class](v...))

def party_config_csv_pos = pos : party_config_csv(pos, _...)

//entity pc csv_pos_to_party =
*/

// --- Player Configs -------------------------

entity pc pc_by_id = id : party_config(id, _,_,_,_)

def party_config = {
    1, "A", "Fighter", 1, 50;
    2, "B", "Water Mage", 2, 30;
    3, "C", "Archer", 3, 40;
    4, "D", "Cleric", 4, 10;
    5, "E", "Fire Mage", 5, 20;
}
def pc_name[p] = v : exists(id : pc_by_id(id,p) and party_config(id, v, _, _, _))
def pc_class[p] = v : exists(id : pc_by_id(id,p) and party_config(id, _, v, _, _))
def pc_init_order[p] = v : exists(id : pc_by_id(id,p) and party_config(id, _, _, v, _))
def pc_max_health[p] = v : exists(id : pc_by_id(id,p) and party_config(id, _, _, _, v))

def start_tile = 0,0
def init_pos[p in pc] = (x-pc_init_order[p],y) from x,y where start_tile(x,y)

// --- Monster Configs -------------------------

def _Monster_health = {
    1,     5;
    2,    10;
}
def _Monster_attack = {
    1,     3;
    2,     5;
}
def _Monster_name = {
    1,     "rat";
    2,     "wolf";
}
entity Monster Monster_by_id = n from n where _Monster_health(n,_)
def Monster_id(m,n) = Monster_by_id(n,m)

def Monster_name[m in Monster] = _Monster_name[Monster_id[m]]
def Monster_max_health[m in Monster] = _Monster_health[Monster_id[m]]
def Monster_attack[m in Monster] = _Monster_attack[Monster_id[m]]

//entity monster_instance
// insert[:monster_position]

ic monsters_on_board_have_stats(m) {
    monster_pos(m, _,_) implies monster_dmg(m, _) and monster_typeid(m, _)
        and monster_facing(m, _, _)
}
ic monster_facing_unit_vec(m,vx,vy) {
        monster_facing(m, vx, vy) implies {-1;0;1}(vx) and {-1;0;1}(vy)
}

def monster_Type[m in monster] = Monster_by_id[monster_typeid[m]]

def monster = m : monster_typeid(m, _)
def monster_health[m in monster] = Monster_max_health[monster_Type[m]] - monster_dmg[m]


// def monster_AI_move[m in monster] =
//     def monster_facing





// --- Game Positioning ---------------------------------------

// Reverse index by tile - players, monster, etc
// TODO: Once we have specialization this will work! :)
// def tile_occupant[x,y] = p : pc[p] and pc_pos(p, x,y)
// def tile_occupant[x,y] = m : monster[m] and monster_pos(m, x,y)

def tile_occupant_pc[x,y] = p : pc[p] and pc_pos(p, x,y)
def tile_occupant_monster[x,y] = m : monster[m] and monster_pos(m, x,y)

// ------------------------------------------------------------

// ============================================================
// === UI Rendering
// ============================================================

// TODO: specialization
// def pc_display_char[p in pc] = substring[pc_name[p], 1,1]
// def Monster_display_char[m in Monster] = substring[Monster_name[m], 1,1]

def pc_display_char = {
    pc_by_id[1], '1';
    pc_by_id[2], '2';
    pc_by_id[3], '3';
    pc_by_id[4], '4';
    pc_by_id[5], '5';
}
def Monster_display_char = {
    Monster_by_id[1], 'R';
    Monster_by_id[2], 'W';
}
def monster_display_char[m] = Monster_display_char[monster_Type[m]]

// TODO: Not constants
def screen_dims = 11, 11 // Keep this odd
def center = 0,0

// TODO: Abstractions?
def screen_width = v : screen_dims(v,_)
def screen_height = v : screen_dims(_,v)
def centerx = v : center(v,_)
def centery = v : center(_,v)

def L = centerx - screen_width รท 2
def R = centerx + screen_width รท 2
def T = centery + screen_height รท 2
def B = centery - screen_height รท 2

def display_grid[x in range[L,R,1], y in range[B,T,1]] =
    if tile_occupant_pc(x,y,_) then pc_display_char[tile_occupant_pc[x,y]]
    else if tile_occupant_monster(x,y,_) then monster_display_char[tile_occupant_monster[x,y]]
    else '.'
    end end

// Flip y axis for printing characters!
def display_lines[row in range[1,screen_height,1], col in range[1,screen_width,1]] =
    display_grid[x, y]
    from (x,y)
    where x = L + col - 1 and y = T - row + 1


// ------------------------------------------------------------


// ============================================================
// === Updates
// ============================================================

//TODO(1898) remove after fixing issue #1898
    def insert(:dummy) = true
    def insert[:move] = (10000, :up)
    def delete[:move] = (10000, :up)
//

def mv_vec = {
    :up,     0, 1;
    :down,   0,-1;
    :left,  -1, 0;
    :right,  1, 0;
}
def mv_dir = d : mv_vec(d,_,_)

@inline def vadd[A, B] = (px+vx, py+vy) from px,py, vx,vy where A(px,py) and B(vx,vy)

def computed_new_pos[p in pc] = vadd[pc_pos[p], mv_vec[d]] from id,d where move(id,d) and pc_by_id[id](p)


// ***** On :tick, update everything ***********

// Update positions based on pending moves.
def delete[:pc_pos](p, x,y) = insert(:tick) and computed_new_pos(p,_,_) and pc_pos(p,x,y)
def insert[:pc_pos](p, x,y) = insert(:tick) and computed_new_pos(p,x,y)

// Delete pending moves.
def delete[:move](v...) = insert(:tick) and move(v...)

